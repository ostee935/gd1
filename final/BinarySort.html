<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Sort</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        canvas {
            border: 1px solid black;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
</head>
<body>
    <div id="score" style="position: absolute; top: 10px; left: 10px; font-size: 20px; color: black;">
        Score: 0
    </div>

    <canvas id="myCanvas"></canvas>
    <script>
        // Initialize canvas
        const canvas = new fabric.Canvas('myCanvas', {
            width: 800,
            height: 600,
            backgroundColor: '#f0f0f0',
            selection: false,
        });

        let score = 0;
        let wavesSpawned = 0;
        let movingSquares = []; // Array to track moving squares
        let movementInterval;

        // Function to update the score
        function updateScore() {
            const scoreElement = document.getElementById('score');
            scoreElement.innerText = `Score: ${score}`;

            // Check if score is a multiple of 50 and spawn 2 additional waves
            if (score >= 50 && score % 50 === 0) {
                spawnAdditionalWaves();
            }
        }

        // Function to add square to movement
        function addSquareToMovement(square) {
            movingSquares.push(square);
        }

        // Function to remove square from movement
        function removeSquareFromMovement(square) {
    const index = movingSquares.indexOf(square);
    if (index > -1) {
        movingSquares.splice(index, 1);
        stopIndividualMovement(square); // Stop individual movement timer
    }
}

// Function to calculate angle towards the center
function calculateAngleTowardsCenter(square, centerX, centerY) {
    const dx = centerX - square.left;
    const dy = centerY - square.top;
    return Math.atan2(dy, dx); // Angle towards the center
}

// Function to create a light gray box at the center
function createCenterBox() {
    const centerBox = new fabric.Rect({
        left: (canvas.width - 400) / 2, // Center it horizontally
        top: (canvas.height - 400) / 2, // Center it vertically
        width: 400, // Box width (updated to 400)
        height: 400, // Box height (updated to 400)
        fill: 'lightgray',
        selectable: false, // Prevent selection
        hasControls: false, // Disable resizing controls
        hasBorders: false, // Disable borders
    });

    canvas.add(centerBox); // Add to canvas
}

// Call the function to create the center box
createCenterBox();


// Call the function to create the center box
createCenterBox();


// Update individual movement logic
function startIndividualMovement(square) {
    const moveInterval = Math.random() * 2000 + 1000; // Random interval between 1-3 seconds

    square.movementTimer = setInterval(() => {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        let angle;
        const distanceFromCenter = Math.sqrt(
            Math.pow(square.left - centerX, 2) + Math.pow(square.top - centerY, 2)
        );

        if (distanceFromCenter > 200) {
            // If too far, calculate angle towards the center
            angle = calculateAngleTowardsCenter(square, centerX, centerY);
        } else {
            // Otherwise, random angle
            angle = Math.random() * 2 * Math.PI;
        }

        const distance = Math.random() * 50 + 10;

        const newLeft = Math.max(
            0,
            Math.min(canvas.width - square.width, square.left + Math.cos(angle) * distance)
        );
        const newTop = Math.max(
            0,
            Math.min(canvas.height - square.height, square.top + Math.sin(angle) * distance)
        );

        square.animate(
            { left: newLeft, top: newTop },
            {
                duration: 400,
                onChange: canvas.renderAll.bind(canvas),
            }
        );
    }, moveInterval);
}

        // Stop individual movement for a square
function stopIndividualMovement(square) {
    clearInterval(square.movementTimer);
}

        // Update createAISquare to include individual movement
function createAISquare(color, base, x, y) {
    const square = new fabric.Rect({
        left: x,
        top: y,
        width: 50,
        height: 60,
        fill: color,
        baseColor: base,
        selectable: true,
        hasControls: false,
        hasBorders: false,
    });

    addSquareToMovement(square); // Add square to movement list
    startIndividualMovement(square); // Start individual movement
    return square;
}

        // Function to create pens
        function createPen(color, base, x, y) {
            const pen = new fabric.Rect({
                left: x,
                top: y,
                width: 150,
                height: 200,
                fill: color,
                baseColor: base,
                selectable: false
            });

            return pen;
        }

        // Doorway for squares
        const doorway = new fabric.Rect({
            left: canvas.width / 2 - 100,
            top: 0,
            width: 200,
            height: 100,
            fill: 'black',
            selectable: false
        });

        // Add objects to canvas
        const darkRedPen = createPen('darkred', 'red', 0, 0);
        const darkGreenPen = createPen('darkgreen', 'green', canvas.width - 150, 0);
        const darkBluePen = createPen('darkblue', 'blue', 0, canvas.height - 200);
        const darkYellowPen = createPen('darkgoldenrod', 'yellow', canvas.width - 150, canvas.height - 200);

        canvas.add(darkRedPen, darkGreenPen, darkBluePen, darkYellowPen);
        canvas.add(doorway);

        // Check for matches and delete matched squares
        function checkMatchAndDelete(square) {
            const pen = canvas.getObjects().find(obj =>
                obj.type === 'rect' && obj.baseColor === square.baseColor && obj !== square
            );

            if (pen &&
                square.left + square.width > pen.left && square.left < pen.left + pen.width &&
                square.top + square.height > pen.top && square.top < pen.top + pen.height) {
                removeSquareFromMovement(square); // Remove from movement list
                canvas.remove(square);
                score += 10;
                updateScore();
            }
        }

        // Initial squares
        const redSquare = createAISquare('red', 'red', 10, 10);
        const greenSquare = createAISquare('limegreen', 'green', 70, 10);
        const blueSquare = createAISquare('blue', 'blue', 130, 10);
        const yellowSquare = createAISquare('gold', 'yellow', 190, 10);


        // Mouse click handling
        canvas.on('mouse:up', function (e) {
            const activeObject = canvas.getActiveObject();
            if (activeObject && activeObject.type === 'rect') {
                checkMatchAndDelete(activeObject);
            }
        });

        // Spawn additional waves
        function spawnAdditionalWaves() {
            for (let i = 0; i < 2; i++) {
                sendBurst();
            }
        }

        // Send a burst of squares
        function sendBurst() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            for (let i = 0; i < 4; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const distance = 50 + Math.random() * 100;

                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;

                const color = ['red', 'blue', 'limegreen', 'gold'][i];
                const base = ['red', 'blue', 'green', 'yellow'][i];
                const newSquare = createAISquare(color, base, x, y);

                canvas.add(newSquare);
            }
        }

        // Initial bursts
        let initialBurstCount = 0;
        const initialMaxBursts = 3;

        const initialBurstInterval = setInterval(() => {
            if (initialBurstCount < initialMaxBursts) {
                sendBurst();
                initialBurstCount++;
            } else {
                clearInterval(initialBurstInterval);
            }
        }, 500);

        // Start movement
        startGlobalMovement();
    </script>
</body>
</html>
