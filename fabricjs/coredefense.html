<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Defense</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        const canvas = new fabric.Canvas('canvas');
        canvas.setBackgroundColor('#0c0c27', canvas.renderAll.bind(canvas));
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 40; // Orbit radius
        let angle = 0; // Initial angle

        // Create Shield
        const rect = new fabric.Rect({
            width: 10,
            height: 40,
            fill: '#990033',
            originX: 'center',
            originY: 'center'
        });

        rect.set({
            left: centerX + radius * Math.cos(angle),
            top: centerY + radius * Math.sin(angle),
            angle: angle * (180 / Math.PI)
        });

        canvas.add(rect);
        
        // Create the core
        const coreCircle = new fabric.Circle({
            radius: 15,
            fill: '#cc0066',
            originX: 'center',
            originY: 'center',
            left: centerX,
            top: centerY
        });

        canvas.add(coreCircle);

        // Pulsing effect
        let state = 'growing';

        setInterval(() => {
            if (state === 'growing') {
                coreCircle.set({ radius: coreCircle.radius + 1 });
                if (coreCircle.radius >= 18) {
                    state = 'resting';
                    setTimeout(() => { state = 'shrinking'; }, 500);
                }
            } else if (state === 'shrinking') {
                coreCircle.set({ radius: coreCircle.radius - 1 });
                if (coreCircle.radius <= 15) {
                    state = 'resting';
                    setTimeout(() => { state = 'growing'; }, 100);
                }
            }
            canvas.renderAll();
        }, 50);

        // Enemy arrays
        const dots = [];
        const newEnemies = [];


        function getRandom(){
            const edge = Math.floor(Math.random() * 4);
            let x, y;

            if (edge === 0) { // Top edge
                x = Math.random() * canvas.width;
                y = 0;
            } else if (edge === 1) { // Right edge
                x = canvas.width;
                y = Math.random() * canvas.height;
            } else if (edge === 2) { // Bottom edge
                x = Math.random() * canvas.width;
                y = canvas.height;
            } else { // Left edge
                x = 0;
                y = Math.random() * canvas.height;
            }
            return {x, y};
        }
            
        // Function to spawn dots
        function spawnDot() {
            const dotRadius = 5;
            const {x, y} = getRandom();

            const dot = new fabric.Circle({
                radius: dotRadius,
                fill: '#ff6600',
                left: x,
                top: y,
                originX: 'center',
                originY: 'center'
            });

            dots.push(dot);
            canvas.add(dot);
        }

        
        // Move dots towards the core
        function moveDots() {
            dots.forEach((dot, index) => {
                const dx = centerX - dot.left;
                const dy = centerY - dot.top;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Normalize the direction
                if (distance > 0) {
                    dot.left += (dx / distance) * 2; // Adjust speed here
                    dot.top += (dy / distance) * 2; // Adjust speed here
                }

                // Remove dot if it reaches the core
                if (distance < coreCircle.radius) {
                    canvas.remove(dot);
                    dots.splice(index, 1);
                }
            });
            canvas.renderAll();
        }

// Function to spawn a more erratic enemy
function spawnBlot() {
    const {x, y} = getRandom();

    const Blot = new fabric.Circle({
        radius: 8,
        fill: '#00ff00',
        left: x,
        top: y,
        originX: 'center',
        originY: 'center'
    });

    newEnemies.push(Blot);
    canvas.add(Blot);
}

function moveBlots() {
    newEnemies.forEach((enemy, index) => {
        const dx = centerX - enemy.left;
        const dy = centerY - enemy.top;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            enemy.left += (dx / distance) * 1;
            enemy.top += (dy / distance) * 1;
            enemy.left += Math.floor(Math.random() * 6) -2.5;
            enemy.top += Math.floor(Math.random() * 2) -1;
        }

        // Remove the new enemy if it reaches the core
        if (distance < coreCircle.radius) {
            canvas.remove(enemy);
            newEnemies.splice(index, 1);
        }
    });
}


        // Mouse function
        function update() {
            canvas.on('mouse:move', function(event) {
                const mouse = canvas.getPointer(event.e);
                const mouseX = mouse.x;
                const mouseY = mouse.y;
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                angle = Math.atan2(dy, dx);
                rect.set({
                    left: centerX + radius * Math.cos(angle) - rect.width / 2,
                    top: centerY + radius * Math.sin(angle),
                    angle: angle * (180 / Math.PI)
                });
                canvas.renderAll();
            });
        }

        // Spawn enemies
        setInterval(spawnDot, 1500);
        setInterval(spawnBlot, 5000);
        
        // Start the update loop
        update();

        // Animation loop
        function animate() {
            moveDots();
            moveBlots();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
