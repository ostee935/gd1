<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Defense</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        const canvas = new fabric.Canvas('canvas');
        canvas.setBackgroundColor('#0c0c27', canvas.renderAll.bind(canvas));
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 40; // Orbit radius
        let angle = 0; // Initial angle

        // Create Shield
        const rect = new fabric.Rect({
            width: 10,
            height: 40,
            fill: '#990033',
            originX: 'center',
            originY: 'center'
        });

        rect.set({
            left: centerX + radius * Math.cos(angle),
            top: centerY + radius * Math.sin(angle),
            angle: angle * (180 / Math.PI)
        });

        canvas.add(rect);
        
        // Create the pulsing core circle
        const coreCircle = new fabric.Circle({
            radius: 15,
            fill: '#cc0066',
            originX: 'center',
            originY: 'center',
            left: centerX,
            top: centerY
        });

        canvas.add(coreCircle);

        // Pulsing effect
        let state = 'growing';

        setInterval(() => {
            if (state === 'growing') {
                coreCircle.set({ radius: coreCircle.radius + 1 });
                if (coreCircle.radius >= 18) {
                    state = 'resting';
                    setTimeout(() => { state = 'shrinking'; }, 500);
                }
            } else if (state === 'shrinking') {
                coreCircle.set({ radius: coreCircle.radius - 1 });
                if (coreCircle.radius <= 15) {
                    state = 'resting';
                    setTimeout(() => { state = 'growing'; }, 100);
                }
            }
            canvas.renderAll();
        }, 50);

        // Enemy array
        const enemies = [];

        // Function to spawn enemies
        function spawnEnemy() {
            const enemyRadius = 5;
            const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y;

            if (edge === 0) { // Top edge
                x = Math.random() * canvas.width;
                y = 0;
            } else if (edge === 1) { // Right edge
                x = canvas.width;
                y = Math.random() * canvas.height;
            } else if (edge === 2) { // Bottom edge
                x = Math.random() * canvas.width;
                y = canvas.height;
            } else { // Left edge
                x = 0;
                y = Math.random() * canvas.height;
            }

            const enemy = new fabric.Circle({
                radius: enemyRadius,
                fill: '#ff6600',
                left: x,
                top: y,
                originX: 'center',
                originY: 'center'
            });

            enemies.push(enemy);
            canvas.add(enemy);
        }

        // Move enemies towards the core
        function moveEnemies() {
            enemies.forEach((enemy, index) => {
                const dx = centerX - enemy.left;
                const dy = centerY - enemy.top;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Normalize the direction
                if (distance > 0) {
                    enemy.left += (dx / distance) * 2; // Adjust speed here
                    enemy.top += (dy / distance) * 2; // Adjust speed here
                }

                // Remove enemy if it reaches the core
                if (distance < coreCircle.radius) {
                    canvas.remove(enemy);
                    enemies.splice(index, 1);
                }
                
                // Remove enemy if it reaches the core
                //if (distance < radius+rect.width) {
                //    canvas.remove(enemy);
                //    enemies.splice(index, 1);
                //}
            });
            canvas.renderAll();
        }

        // Update function
        function update() {
            canvas.on('mouse:move', function(event) {
                const mouse = canvas.getPointer(event.e);
                const mouseX = mouse.x;
                const mouseY = mouse.y;
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                angle = Math.atan2(dy, dx);
                rect.set({
                    left: centerX + radius * Math.cos(angle) - rect.width / 2,
                    top: centerY + radius * Math.sin(angle),
                    angle: angle * (180 / Math.PI)
                });
                canvas.renderAll();
            });
        }

        // Spawn an enemy every 2 seconds
        setInterval(spawnEnemy, 700);
        
        // Start the update loop
        update();

        // Animation loop
        function animate() {
            moveEnemies();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
